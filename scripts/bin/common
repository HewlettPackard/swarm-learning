#!/usr/bin/env bash

######################################################################
## (C)Copyright 2021-2023 Hewlett Packard Enterprise Development LP
## Licensed under the Apache License, Version 2.0 (the "License"); you may
## not use this file except in compliance with the License. You may obtain
## a copy of the License at
##
##    http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
## WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
## License for the specific language governing permissions and limitations
## under the License.
######################################################################

################################################################################
## Notes on "sidecar" container support
## ------------------------------------
## We allow the user to specify an arbitrary number of "sidecars" that we should
## run along with the main container. These sidecars are freely configurable by
## the user - since these are arbitrary containers, we do not (and cannot) take
## much responsibility for supplying any parameters that might be required. We
## need a scheme to associate command line parameters with the right sidecar to
## support this model. For the data structure, we have two choices - either one
## single, giant dictionary that contains all the parameters or several smaller
## ones. We go with several small arrays because it is easier to integrate with
## our existing code. Accordingly, we create these arrays and scalar variables:
##  1. sidecars - an associative name for each sidecar. This name might be set
##     either internally for known sidecars, such as the user ML container and
##     the decoupled SPIRE agent (assuming we support it) or by the user using
##     the --sidecar parameter. Whether internal or external, for every sidecar,
##     we mandatorily require an entry in this array. Its value, with a leading
##     double dash, is prefixed to all sidecar command line parameters. And its
##     camel-cased value is prefixed to all sidecar configuration property array
##     variables. For example, if the decoupled SPIRE agent is given the name,
##     "spire-agent", the command line parameter to specify its image would be,
##     "--spire-agent-image". The corresponding value for this property would be
##     stored in a variable called, "spireAgentImage".
##  2. ${camelCasedSidecarName}Image, ${camelCasedSidecarName}Entrypoint, etc. -
##     scalar variables that hold corresponding single-value properties.
##  3. ${camelCasedSidecarName}Ports, ${camelCasedSidecarName}BindMounts, etc. -
##     array variables to hold lists of values.
##  4. ${camelCasedSidecarName}PidMain - this is a special variable to specify
##     that the process namespace should be shared between the sidecar and the
##     main container. To share the process namespace with other sidecars, name
##     the containers and then, use --<sidecar1-name>-pid <sidecar2-name>.
##  5. ${camelCasedSidecarName}VolumesFromMain - this is another special flag to
##     specify that all anonymous volumes associated with the main container are
##     to be mounted onto the sidecar. The mechanism for mounting volumes from
##     other sidecars is similar to that for sharing process namespaces - name
##     them and then, use --<sidecar1-name>-volumes-from <sidecar2-name>. We do
##     not try to detect and avoid conflicting mounts. The result of a conflict
##     is undefined.
## We launch the main container first and then, the sidecars in the order that
## they were declared on the command line. The user must bear this in mind when
## defining PID namespace sharing and anonymous volume mount properties. In the
## examples above, sidecar1 refers to sidecar2's namespace and volumes. sidecar2
## must be launched first and only then, sidecar1, for this to work. Therefore,
## "--sidecar sidecar2" must precede "--sidecar sidecar1" on the command line.
## Note that the other sidecar configuration properties can occur in any order.
## The order requirement applies only to the sidecar parameter. Currently, The
## use of this sidecar is being managed entirely from common script. In future
## if need arise, changes to be done on the individual swarm component scripts.
################################################################################


# Enable extended pattern matching in case statements.
shopt -s extglob

# Enable case-insensitive matching in case statements.
shopt -s nocasematch


ourPID=$$
trap "exit 1" SIGUSR1 SIGUSR2


# Swarm product version.
swarmVer="2.1.0"

swarmDockerHub="hub.myenterpriselicense.hpe.com"
swarmOrg="hpe/swarm-learning"

slRepoName="sl"
snRepoName="sn"
swciRepoName="swci"
swopRepoName="swop"

slImage="${swarmDockerHub}/${swarmOrg}/${slRepoName}:${swarmVer}"
snImage="${swarmDockerHub}/${swarmOrg}/${snRepoName}:${swarmVer}"
swciImage="${swarmDockerHub}/${swarmOrg}/${swciRepoName}:${swarmVer}"
swopImage="${swarmDockerHub}/${swarmOrg}/${swopRepoName}:${swarmVer}"

# If podman is installed we don't need elevate privileges so sudo or docker group not required 
# else we need elevated privileges to run docker commands, if the current user is not
# a member of the docker group. 
# Given, the user has configured password-less sudo

if ! command -v podman &>/dev/null; then
    id -Gn 2> /dev/null | grep "\(\<docker\>\)\|\(\<root\>\)" > /dev/null 2>&1
    [[ ${?} -ne 0 ]] && sudo="sudo"
fi


# Order of process and usage functions to call.
funcCallOrder=()


# By default, we keep the containers after they exit. The user must pass "--rm"
# on the command line to remove them automatically.
rm=


# Note that this is an array with an empty first element. The first element maps
# to the main container. This is functionally the same as:
#   sidecars=
# And, it is NOT the same as:
#   sidecars=()
# We have opted for readability here.
declare -a sidecars
sidecars[0]=

indent=" "


error()
{
    # Print the error message, if there is one.
    [[ -n "${1}" ]] && echo "${progName}: ${1}" >&2
    kill -s SIGUSR1 ${ourPID}
}


camelCase()
{
    # https://unix.stackexchange.com/questions/196239.
    # The first sed nukes all leading dashes. The second upper-cases everything
    # that follows one or more dashes while also nuking the dashes.
    echo "${1}" | sed -r 's/^-+//;s/-+(.)/\U\1/g'
}


# CamelCase upper-cases the first character of the first word. camelCase leaves
# this as is:
#      | Input     | camelCase | CamelCase
#   ---|-----------|-----------|----------
#   1. | --foo-bar | fooBar    | FooBar
#   2. | --Foo-bar | FooBar    | FooBar
#   3. | foo-bar   | fooBar    | FooBar
#   4. | Foo-bar   | FooBar    | FooBar
CamelCase()
{
    # https://unix.stackexchange.com/questions/196239.
    echo "${1}" | sed -r 's/-+(.)/\U\1/g;s/^(.)/\U\1/'
}


# Params:
#   1. Optional prefix.
#   2. Variable name.
makeVarName()
{
    echo "$(camelCase "${1}${2}")"
}


# Params:
#   1. Variable name prefix
#   2. Variable name.
#   3. Value.
assignVar()
{
    declare -n var="$(makeVarName "${1}" "${2}")"
    shift 2
    var="${@}"

    return 0
}


# Params:
#   1. Variable name prefix
#   2. Variable name.
#   3. Value.
appendVar()
{
    declare -n var="$(makeVarName "${1}" "${2}")"
    shift 2
    var="${var} ${@}"

    return 0
}


# Params:
#   1. Variable name prefix
#   2. Variable name.
#   3. Value.
assignArrayVar()
{
    declare -n var="$(makeVarName "${1}" "${2}")"
    shift 2
    [[ ${#} -gt 0 ]] && var[0]="${@}" || var=()

    return 0
}


# Params:
#   1. Variable name prefix
#   2. Variable name.
#   3. Value.
appendArrayVar()
{
    declare -n var="$(makeVarName "${1}" "${2}")"
    shift 2
    var+=("${@}")

    return 0
}


# Search an array for an element.
# Params:
#   1. Array name.
#   2. Optional sidecar prefix.
#   3. The element to search for.
#   4. Optional flags for grep.
#   5. Optional flag to specify whether the whole element must match, instead of
#      substrings.
# -F and -Fx(whole word) are the options for fastest way of searching in an array.
# On usage of -Fq, q option exits the search on first match 
# IFS means Internal Field Separator
#  Refer https://stackoverflow.com/a/42314749.
hasItem()
{
    declare -n arrayVar=$(makeVarName "${2}" "${1}")
    [[ -n "${5}" ]] && local grepFlags="-Fx${4}" || local grepFlags="-F${4}"

    
    ( IFS=$'\n'; echo "${arrayVar[*]}" ) | grep ${grepFlags} -- "${3}"

    return ${?}
}

# Verifies if value is present for the given argument.
# {1:0:1} will get first and only the first character from first argument. 
# Here 0 is the head character index and 1 is string length.
# Params:
#   1. optarg

hasOptarg()
{
    [[ -n "${1}" && "${1:0:1}" != "-" ]]
}

# Checks for the value of the argument.
# Calls hasOptOrg to verify if it has value or not
# Params:
#   1. opt
#   2. optarg
checkOptarg()
{
    ! hasOptarg "${2}" && error "${1}: missing argument"
    return 0
}


# Params:
#   1. The command line switch.
#   2. The value to assign.
#   3. Optional prefix for value.
#   4. Optional name of variable.
#   5. Optional sidecar prefix.
checkAndAssign()
{
    checkOptarg "${1}" "${2}"
    [[ -n "${4}" ]] && \
        assignVar "${5}" "${4}" "${3}${2}" || assignVar "" "${1}" "${3}${2}"
    return 0
}



# Params:
#   1. The command line switch.
#   2. The value to assign.
#   3. Optional prefix for value.
#   4. Optional name of array.
#   5. Optional sidecar prefix.
#   6. Optional flag to specify whether prefix should be a separate array item.
#   7. Optional flag to specify whether the value should be split into several
#      items that are appended individually to the array. Splitting splits the
#      value around whitespace characters. For example, splitting "foo bar" will
#      produce two array elements - "foo" and "bar".
#   8. Optional flag to specify whether checks on the value should be skipped.
#   9. Optional flag to specify whether the value is optional.
#  10. Optional default value to use when an optional value is not specified.
checkAndAppend()
{
    local optarg=
    local val=()

    if [[ -n "${8}" ]] || hasOptarg "${2}"
    then
        # Either skip checks in this case or, an arg has been provided.
        optarg="${2}"
    elif [[ -n "${9}" ]]
    then
        # Missing optional arg; use default.
        optarg="${10}"
    else
        error "${1}: missing argument"
    fi

    [[ -n "${3}" && -n "${6}" ]] && val+=("${3}" "${optarg}") || val+=("${3}${optarg}")

    # The quintessential command line parameter and its corresponding value has
    # the form:
    #       --foo=bar
    # However, we have a use case for whitespace-separated, multi-word values:
    #       --foo="bar baz"
    # The quintessential example of this is:
    #       --ml-cmd="python3 /path/to/user-ml-program.py [arg]..."
    # Such a value must be split and presented as several, individual arguments
    # to the "docker run" command and not as a single mega string:
    #       Wrong invocation:
    #           docker run ml-img "python3 /path/to/user-ml-program.py [arg]..."
    # This will fail because it will make docker look for an executable called
    # "python3 /path/to/user-ml-program.py [arg]..."
    #       Correct invocation:
    #           docker run ml-img python3 /path/to/user-ml-program.py [arg]...
    # So, we provide some support for this. Our implementation is complicated by
    # two considerations:
    #   1. The quintessential onTrainEnd function adds all unprocessed options
    #      to the cmd array. These should not be subjected to splitting because
    #      they have already been split by the shell. Therefore, splitting must
    #      be performed here and not when we are constructing the "docker run"
    #      command.
    #   2. We want to support whitespaces as a part of the argument:
    #       --foo="\"bar baz\""
    #      In the example above, foo should be set to a single value, "bar baz",
    #      not "bar" and "baz".
    # Our implementation is based on https://stackoverflow.com/a/36281632. But,
    # these additional resources deserve a special mention for being excellent
    # reading material:
    #   1. http://mywiki.wooledge.org/BashFAQ/050
    #   2. http://mywiki.wooledge.org/WordSplitting
    #   3. http://mywiki.wooledge.org/Arguments
    #   4. http://mywiki.wooledge.org/Quotes
    # xargs performs the critical job of word splitting. We cannot use standard,
    # well-understood pipes to feed the printf output to readarray. We muse use
    # process substitution. https://unix.stackexchange.com/a/263885 explains why
    # pipes do not work.
    # We do not want a potential conflict with a user-specified newline. So we
    # use the null character as the delimiter.
    # We do not see a need to split before handling $3 and $6.
    # Note that we support only arrays at the moment. But, this can be extended
    # to checkAndAssign too, should the need arise.
    [[ -n "${7}" ]] &&  \
        readarray -d $'\0' val < <(xargs printf "%s\0" <<< "${val[@]}")

    [[ -n "${4}" ]]                                 \
     && appendArrayVar "${5}" "${4}" "${val[@]}"    \
     || appendArrayVar "" "${1}" "${val[@]}"

    return 0
}


# Params:
#   1. The command line switch.
#   2. The user-specified value to be assigned.
#   3. The default value to be used, if the user does not specify one.
checkAndAssignOptVal()
{
    if ! hasOptarg "${2}"
    then
        # Missing argument
        checkAndAssign "${1}" "${3}"
        return 1
    else
        checkAndAssign "${1}" "${2}"
        return 0
    fi
}


source <(perl "${progDir}/docker-opts.pl" ${sudo})

# All Docker related common options are now moved to docker-opts.pl. This perl script
# will print the usage help text by looping through the list of options within the 
# "docker container create" command.
printCommonUsage()
{
    printf -- "\nCommon Options:\n"
    printf -- "%4s--\n" "${indent}"
    printf -- "%8sEnd of switches.\n" "${indent}"
    printf -- "%8sAll command line parameters that follow this\n" "${indent}"
    printf -- "%8sare passed directly to the target container.\n\n" "${indent}"


    printf -- "%4s--cmd args\n" "${indent}"
    printf -- "%8sSet of command line arguments for the entrypoint.\n\n" "${indent}"


    printf -- "%4s--pid-main\n" "${indent}"
    printf -- "%8sUse the main container's PID namespace.\n\n" "${indent}"

    printf -- "%4s--sudo\n" "${indent}"
    printf -- "%8sPrefix docker commands with \"sudo\".\n" "${indent}"
    printf -- "%8sDefault: false, if the current user belongs to the docker\n" "${indent}"
    printf -- "%8sgroup; true otherwise\n\n" "${indent}"

    printf -- "%4s--volumes-from-main\n" "${indent}"
    printf -- "%8sMount all defined volumes from the main container.\n\n" "${indent}"

    printf -- "%4s-h, --help\n" "${indent}"
    printf -- "%8sThis (helpful) message.\n\n" "${indent}"

    return 0
}


printAPLSUsage()
{
    printf -- "\nAPLS Options:\n"
    printf -- "%4s--apls-ip <IP address or DNS name>\n" "${indent}"
    printf -- "%8sSynonym for --primary-apls-ip.\n" "${indent}"
    printf -- "%8sDefault: $(hostname -I | cut -d' ' -f1)\n\n" "${indent}"

    printf -- "%4s--primary-apls-ip <IP address or DNS name>\n" "${indent}"
    printf -- "%8sThe IP address on which the primary Autopass License Server is serving license requests.\n" "${indent}"
    printf -- "%8sDefault: $(hostname -I | cut -d' ' -f1)\n\n" "${indent}"

    printf -- "%4s--secondary-apls-ip <IP address or DNS name>\n" "${indent}"
    printf -- "%8sThe IP address on which the secondary Autopass License Server is serving license requests.\n" "${indent}"
    printf -- "%8sDefault: None\n\n" "${indent}"

    printf -- "%4s--apls-port <port number>\n" "${indent}"
    printf -- "%8sSynonym for --primary-apls-port.\n" "${indent}"
    printf -- "%8sDefault: 5814\n\n" "${indent}"

    printf -- "%4s--primary-apls-port <port number>\n" "${indent}"
    printf -- "%8sThe port number on which the primary Autopass License Server is serving license requests.\n" "${indent}"
    printf -- "%8sDefault: 5814\n\n" "${indent}"

    printf -- "%4s--secondary-apls-port <port number>\n" "${indent}"
    printf -- "%8sThe port number on which the secondary Autopass License Server is serving license requests.\n" "${indent}"
    printf -- "%8sDefault: the value assigned to --primary-apls-port\n\n" "${indent}"
    return 0
}


printUserIDUsage()
{
    printf -- "\nUser ID Options:\n"
    printf -- "%4s--cacert <path to certificates file>\n" "${indent}"
    printf -- "%8sThe path to the file containing the list of CA certificates.\n" "${indent}"
    printf -- "%8sDefault: None\n\n" "${indent}"

    printf -- "%4s--capath <path to certificates directory>\n" "${indent}"
    printf -- "%8sThe path to the directory containing CA certificate files.\n" "${indent}"
    printf -- "%8sDefault: None\n\n" "${indent}"

    printf -- "%4s--cert <path to certificate file>\n" "${indent}"
    printf -- "%8sThe path to the certificate file that provides the component's ID.\n" "${indent}"
    printf -- "%8sDefault: None\n\n" "${indent}"

    printf -- "%4s--key <path to key file>\n" "${indent}"
    printf -- "%8sThe path to the private key file corresponding to the certificate.\n" "${indent}"
    printf -- "%8sDefault: None\n\n" "${indent}"

    return 0
}


printSpiffeIDUsage()
{
    printf -- "\nSPIFFE ID Options:\n"
    printf -- "%4s--socket-path <SPIFFE Workload API socket>\n" "${indent}"
    printf -- "%8sPath, volume or container hosting the socket on which the SPIFFE Agent serves the Workload API.\n" "${indent}"
    printf -- "%8sDefault: None\n\n" "${indent}"

    return 0
}


usage()
{
    # Print the message, if there is one.
    [[ -n "${1}" ]] && echo "${progName}: ${1}"

    printf -- "${progName}: usage: ${progName} [ OPTIONS ]\n"
    printf -- "Options:\n"
    for funcName in "${funcCallOrder[@]}"
    do
        declare -F "print${funcName}Usage" > /dev/null && print${funcName}Usage
    done

    return 0
}


isLocalhost()
{
    # TODO: check whether there is a "universal" alternative for hostname -I. -I
    # does not work on some Linux flavours, like Alpine. They accept only -i. -i
    # on Ubuntu returns 127.0.1.1.
    local ourIP=$(hostname -I | cut -d' ' -f1)
    local ourFQDN=$(hostname -f)
    local ourHostname=$(hostname)

    [[ "${1}" == "${ourIP}"        \
    || "${1}" == "${ourFQDN}"      \
    || "${1}" == "${ourHostname}" ]]
}


# Given an IP address and an image label, try and find a running container with
# those attributes and, return a "docker exec" command that can connect to it.
# Params:
#   1. Image label.
#   2. Optional image name. There could be several running container instances
#      on a system for the image. We must connect to the right one - we rely on
#      the user telling us which one to pick. This parameter can be omitted (by
#      passing in an empty string) when the caller knows there is only a single
#      running instance of the image.
#   3. Optional IP address. This can be either an IP or a DNS name. Further, it
#      can be the IP or name of the host system or that of the container itself
#      (when the container is connected to a dedicated network bridge, we expect
#      this parameter to represent the IP of the container and not that of the
#      host system.) When this parameter is omitted, we assume the container is
#      running on the local host. The container can also run on a remote system.
#      In this case, this parameter is required and should represent the IP of
#      the remote host. Further, the user should have configured a password-less
#      SSH login to the remote system (including a login for the root user, when
#      sudo is required to run docker) for this to work.
#   4. A descriptive name for the image - to include in error messages.
genDockerExec()
{
    # Command to get the "right" running instance of the image. We do not prefix
    # ${sudo} here because its position depends on whether we are running on the
    # local system on a remote one.
    local dockerPSCmd="docker ps --format {{.Names}}"
    [[ -n "${2}" ]] &&                          \
        dockerPSCmd+=" --filter=name=${2}" ||   \
        dockerPSCmd+=" --filter=ancestor=${1}"

    # TODO: check whether there is a "universal" alternative for hostname -I. -I
    # does not work on some Linux flavours, like Alpine. They accept only -i. -i
    # on Ubuntu returns 127.0.1.1.
    local containerName="$(${sudo} ${dockerPSCmd})"

    if [ -n "${containerName}" ]
    then
        # The specified server address might be an internal one - especially if
        # the containers are running on a dedicated bridge network.
        # TODO: handle the case where there are multiple values.

        # The tr command is required. hostname, for reasons completely unknown,
        # adds a carriage return to the output. This makes a comprehensive mess
        # of everything and so, should be removed before it can do any mischief.
        # The '\r' is sufficient. We have added the '\n' as a safety measure.
        local containerIP="$(${sudo}                                        \
            docker exec ${containerName} hostname -i | tr -d '\r\n')"
        local containerFQDN="$(${sudo}                                      \
            docker exec ${containerName} hostname -f | tr -d '\r\n')"
        local containerHostname="$(${sudo}                                  \
            docker exec ${containerName} hostname | tr -d '\r\n')"
    fi
    if [[ -z "${containerName}" ]]
    then
        error "cannot contact ${3}"
    fi
    # [ sudo ] docker exec <container-name>.
    echo "${sudo} docker exec ${containerName}"

    return 0
}


processSidecarBatchOpt()
{
    local sidecar="${1}"        # Ignored.
    local origParam="${2}"
    local opt="${3}"
    local optarg="${4}"

    if [[ "${opt}" == "--sidecar" ]]
    then
        checkAndAppend "${opt}" "${optarg}" "" sidecars
    else
        unprocessedOpts+=("${origParam}")
        nShift=1
    fi

    return 0
}


processCommonBatchOpt()
{
    local sidecar="${1}"
    local origParam="${2}"
    local opt="${3}"
    local optarg="${4}"

    [[ -n "${sidecar}" ]] && local sidecarPrefix="${sidecar}-"

    case "${opt}" in
        # General options that are not related to any container - be it main or
        # sidecar.

        # Unfortunately, -h is a docker option for specifying the hostname.
        --help) usage && exit 0;;
        --sudo) sudo="sudo"; nShift=1;;

        # Container-specific options.
        --${sidecarPrefix}cmd)
            checkAndAppend "${opt}" "${optarg}" "" "" "" "" "y";;

        --${sidecarPrefix}image)
            checkAndAssign "${opt}" "${optarg}";;

        --${sidecarPrefix}pid-main)
            assignVar "${sidecarPrefix}" pidMain "y"; nShift=1;;

        --${sidecarPrefix}volumes-from-main)
            assignVar "${sidecarPrefix}" volumesFromMain "y"; nShift=1;;

        *) unprocessedOpts+=("${origParam}"); nShift=1;;
    esac

    return ${?}
}


onCommonBatchEnd()
{
    [[ -n "${1}" ]] && local sidecarPrefix="${1}-"

    declare -n imgNameVar=$(makeVarName "${sidecarPrefix}" "imageName")
    declare -n imgTagVar=$(makeVarName "${sidecarPrefix}" "imageTag")
    declare -n imgVar=$(makeVarName "${sidecarPrefix}" "image")

    declare -n defImgNameVar=$(makeVarName "${sidecarPrefix}" defaultImageName)
    declare -n defImgTagVar=$(makeVarName "${sidecarPrefix}" defaultImageTag)

    [[ -z "${imgNameVar}" ]] && imgNameVar="${defImgNameVar}"
    [[ -z "${imgTagVar}" ]] && imgTagVar="${defImgTagVar}"
    [[ -z "${imgVar}" ]] && {                               \
        [[ -n "${imgTagVar}" ]]                             \
         && imgVar="${imgNameVar}:${imgTagVar}"             \
         || imgVar="${imgNameVar}"                          \
         ;                                                  \
    }
    return 0
}


processDockerAttachOpt()
{
    local sidecar="${1}"
    local origParam="${2}"
    local opt="${3}"
    local optarg="${4}"

    [[ -n "${sidecar}" ]] && local sidecarPrefix="${sidecar}-"

    # The sidecar prefix is stripped by processDockerBatchOpt. Add it back.
    opt="${sidecarPrefix}${opt}"

    local detachVar=$(makeVarName "${sidecarPrefix}" detach)

    [[ -n "${!detachVar}" ]] && \
        error "conflicting options: ${opt} and --${sidecarPrefix}detach"

    checkAndAppend "${opt}" "${optarg}" "--attach=" "dockerOpts" "${sidecarPrefix}"

    return 0
}


processDockerDetachOpt()
{
    local sidecar="${1}"
    local origParam="${2}"
    local opt="${3}"
    local optarg="${4}"

    [[ -n "${sidecar}" ]] && local sidecarPrefix="${sidecar}-"

    # The sidecar prefix is stripped by processDockerBatchOpt. Add it back.
    opt="${sidecarPrefix}${opt}"

    [[ "${optarg}" != "true" && "${optarg}" != "false" ]] &&  \
        error "${opt}: illegal value ${4}: expected either true or false"

    [[ "${optarg}" == "true" ]]                                         \
     && hasItem "dockerOpts" "${sidecarPrefix}" "--attach" "q"          \
     && error "conflicting options: --${sidecarPrefix}attach and ${opt}"

    declare -n detachVar=$(makeVarName "${sidecarPrefix}" detach)

    [[ "${optarg}" == "true" ]] && detachVar="${optarg}" || detachVar=

    return 0
}


processDockerVolumeOpt()
{
    local sidecar="${1}"
    local origParam="${2}"
    local opt="${3}"
    local optarg="${4}"

    [[ -n "${sidecar}" ]] && local sidecarPrefix="${sidecar}-"

    checkOptarg "${opt}" "${optarg}"

    # A volume specification has three parts, separated by colons:
    #   1. Source - Either a volume name or a local file or directory.
    #   2. Target - The mount point inside the container.
    #   3. Options
    # The Source and Options fields are optional. A volume that does not
    # exist is created automatically. File and directory references must
    # be specified as absolute paths. But, as a convenience, we accept a
    # non-absolute path and convert it to an absolute one. This creates
    # a problem with artifacts that are in the current directory:
    #   -v foo:/mount/point/for/foo
    # Should we treat foo as a (perhaps not-yet-created) volume or as a
    # bind artifact? We impose a restriction to help us resolve this: a
    # source specification for a bind mount must have at least one path
    # separator. Therefore:
    #   -v foo:/mount/point/for/foo
    # refers to a volume mount; while:
    #   -v ./foo:/mount/point/for/foo
    # refers to a bind mount.

    # https://linuxhandbook.com/bash-split-string.
    # This logic splits the string into an array based on a delimiter
    # IFS means Internal Field Separator
    IFS=':' read -ra specParts <<< "${optarg}"

    # specParts is now an array. Based on the number of arguments
    # it goes to repective case statement.
    case "${#specParts[@]}" in
        1) mntTgt="${specParts[0]}";;

        2)
            # This could be either a "src:tgt" or a "tgt:opt". We rely
            # on target having to be an absolute path to determine the
            # form that we have.
            [[ "${specParts[1]}" =~ ^/.+ ]]                             \
             && { optSrc="${specParts[0]}"; mntTgt="${specParts[1]}"; } \
             || { mntTgt="${specParts[0]}"; optOpt=":${specParts[1]}"; }
            ;;

        3)
            optSrc="${specParts[0]}"
            mntTgt="${specParts[1]}"
            optOpt=":${specParts[2]}"
            ;;
    esac

    if [ -n "${optSrc}" ]
    then
        # Splits 'Src' based on '/' delimiter and checks first field.
        # Filters only line that contains delimiter
        if [ -n "$(echo "${optSrc}" | cut -d'/' -f1 -s)" ]
        then
            # Bind mount.
            # checks the existence of the file
            [[ ! -e "${optSrc}" ]] && error "${opt}: ${optarg}: bad mount"
            optSrc="$(realpath "${optSrc}"):"
        else
            # Volume mount.
            optSrc="${optSrc}:"
        fi
    fi

    mountSpec="${optSrc}${mntTgt}${optOpt}"
    appendArrayVar "${sidecarPrefix}" dockerOpts "--volume=${mountSpec}"

    return 0
}


onDockerBatchEnd()
{
    [[ -n "${1}" ]] && local sidecarPrefix="${1}-"

    declare -n dockerOptsVar=$(makeVarName "${sidecarPrefix}" dockerOpts)
    local name=$(hasItem "dockerOpts" "${sidecarPrefix}" "--name")

    # When the user specifies a name but not a hostname, we use the name field
    # for the hostname also. This allows us to specify meaningful arguments for
    # parameters like --sn-ip when we want to keeps things contained to a docker
    # network and do not want to publish ports.
    ! hasItem "dockerOpts" "${sidecarPrefix}" "--hostname" "q"  \
        && [ -n "${name}" ] && dockerOptsVar+=("${name/name/hostname}")
    
    # The below code is to replicate the fix given for 1.1.0 release
    # This conditional logic keeps additional safety measure to run ml container with
    # primary group id of the "user id" passed. If group id is not passed along with the user id in the
    # --ml-user argument then container will run with 0 as group id which is not right approach
    # So, We explicitly add primary group id to the argument when not passed by user.

    if [[ ${sidecarPrefix} == "ml-" ]] && hasItem "dockerOpts" "${sidecarPrefix}" "--user" "q"
    then
        local i=0 idx="" optionVal="" searchStr="--user="
        for item in  "${dockerOptsVar[@]}";
        do
            if [[ ${item} = ${searchStr}* ]]
            then 
                optionVal=${item#${searchStr}}
                idx=${i}
            fi
            ((i=i+1))
        done
        [[ -n ${optionVal} ]] && [[ -n ${idx} ]] && dockerOptsVar[${idx}]="--user=${optionVal}:$(id -g ${optionVal})"
    fi
    return 0
}


processAPLSBatchOpt()
{
    local sidecar="${1}"
    local origParam="${2}"
    local opt="${3}"
    local optarg="${4}"

    [[ -n "${sidecar}" ]] && local sidecarPrefix="${sidecar}-"

    case "${opt}" in
        --${sidecarPrefix}apls-@(ip|port))
            checkAndAssign "${opt}" "${optarg}";;
        --${sidecarPrefix}@(primary|secondary)-apls-@(ip|port))
            checkAndAssign "${opt}" "${optarg}";;
        *) unprocessedOpts+=("${origParam}"); nShift=1;;
    esac

    return ${?}
}


onAPLSBatchEnd()
{
    local sidecar="${1}"

    [[ -n "${sidecar}" ]] && return 0

    [[ -z "${primaryAplsIp}" ]] && primaryAplsIp="${aplsIp}"
    [[ -z "${primaryAplsPort}" ]] && primaryAplsPort="${aplsPort}"



    [[ -n "${primaryAplsIp}" ]] &&                      \
        appendArrayVar "${sidecarPrefix}" dockerOpts    \
            "--env=SWARM_LICENSE_AUTOPASSJ_SERVER_PRIMARY_IP=${primaryAplsIp}"

    [[ -n "${primaryAplsPort}" ]] &&                    \
        appendArrayVar "${sidecarPrefix}" dockerOpts    \
            "--env=SWARM_LICENSE_AUTOPASSJ_SERVER_PRIMARY_PORT=${primaryAplsPort}"

    [[ -n "${secondaryAplsIp}" ]] &&                    \
        appendArrayVar "${sidecarPrefix}" dockerOpts    \
            "--env=SWARM_LICENSE_AUTOPASSJ_SERVER_SECONDARY_IP=${secondaryAplsIp}"

    [[ -n "${secondaryAplsPort}" ]] &&                  \
        appendArrayVar "${sidecarPrefix}" dockerOpts    \
            "--env=SWARM_LICENSE_AUTOPASSJ_SERVER_SECONDARY_PORT=${secondaryAplsPort}"
    return 0
}


processUserIDBatchOpt()
{
    local sidecar="${1}"
    local origParam="${2}"
    local opt="${3}"
    local optarg="${4}"

    [[ -n "${sidecar}" ]] && local sidecarPrefix="${sidecar}-"

    case "${opt}" in
        --${sidecarPrefix}cacert)
            checkAndAssign "${opt}" "${optarg}"
            [[ ! -f "${optarg}" ]] && error "${optarg}: bad file"
            appendArrayVar "${sidecarPrefix}" dockerOpts                    \
                "--volume=$(realpath ${optarg}):$(realpath ${optarg}):ro"   \
                "--env=SWARM_ID_CACERT=$(realpath ${optarg})"
            ;;

        --${sidecarPrefix}capath)
            checkAndAssign "${opt}" "${optarg}"
            [[ ! -d "${optarg}" ]] && error "${optarg}: bad directory"
            appendArrayVar "${sidecarPrefix}" dockerOpts                    \
                "--volume=$(realpath ${optarg}):$(realpath ${optarg}):ro"   \
                "--env=SWARM_ID_CAPATH=$(realpath ${optarg})"
            ;;

        --${sidecarPrefix}cert)
            checkAndAssign "${opt}" "${optarg}"
            [[ ! -f "${optarg}" ]] && error "${optarg}: bad file"
            appendArrayVar "${sidecarPrefix}" dockerOpts                    \
                "--volume=$(realpath ${optarg}):$(realpath ${optarg}):ro"   \
                "--env=SWARM_ID_CERT=$(realpath ${optarg})"
            ;;

        --${sidecarPrefix}key)
            checkAndAssign "${opt}" "${optarg}"
            [[ ! -f "${optarg}" ]] && error "${optarg}: bad file"
            appendArrayVar "${sidecarPrefix}" dockerOpts                    \
                "--volume=$(realpath ${optarg}):$(realpath ${optarg}):ro"   \
                "--env=SWARM_ID_KEY=$(realpath ${optarg})"
            ;;

        *) unprocessedOpts+=("${origParam}"); nShift=1;;
    esac

    return 0
}


processSpiffeIDBatchOpt()
{
    local sidecar="${1}"
    local origParam="${2}"
    local opt="${3}"
    local optarg="${4}"

    [[ -n "${sidecar}" ]] && local sidecarPrefix="${sidecar}-"

    case "${opt}" in
        --${sidecarPrefix}socket-path)
            checkOptarg "${opt}" "${optarg}"

            # The value can represent one of four things:
            #   1. Path to a socket file - we are lucky in this case.
            #   2. A volume name or ID.
            #   3. A container name or ID.
            #   4. A volume name or ID and the path to the socket file relative
            #      to the mount point, separated by a colon.
            # For the second and third case, we try and locate the actual socket
            # file - the envvar requires this.
            if [[ -S "${optarg}" ]]
            then
                local sockfile="$(basename "${optarg}")"
                appendArrayVar "${sidecarPrefix}" dockerOpts                      \
                    "--volume=$(realpath ${optarg}):/tmp/spire-agent/${sockfile}" \
                    "--env=SWARM_SPIFFE_WORKLOAD_API_SOCKET_PATH=/tmp/spire-agent/${sockfile}"
            elif [[ -n "$(echo "${optarg}" | cut -s -d':' -f2)" ]]
            then
                # Case 4: volume name, followed by the socket path.
                local volname="$(echo "${optarg}" | cut -s -d':' -f1)"
                local sockpath="$(echo "${optarg}" | cut -s -d':' -f2)"

                [[ -z "${volname}" || -z "${sockpath}" ]] && \
                    error "${optarg}: bad socket path"

                appendArrayVar "${sidecarPrefix}" dockerOpts                \
                    "--volume=${volname}:/tmp/spire-agent"                  \
                    "--env=SWARM_SPIFFE_WORKLOAD_API_SOCKET_PATH=/tmp/spire-agent/${sockpath}"
            else
                # Try and detect socket files. For a container, we get a list of
                # all volumes and then, search within them for socket files. For
                # a volume, we, er, search within the volume.
                # If the search turns up more than one socket, we use the first
                # one.
                # Note that the "find" requires sudo. Only the root user has any
                # permissions on the directory representing a docker volume.
                [[ $(id -u) -ne 0 ]] && \
                    local sudoForFind="sudo" || local sudoForFind=

                # Volumes have a name while bind mounts do not. We use this fact
                # to filter out bind mounts from our search - our typical agent
                # mounts /var/run/docker.sock and we do not want that to turn up
                # as the first socket.
                local firstSocket="$(${sudoForFind} find    \
                    $(                                      \
                        ${sudo} docker inspect ${optarg}    \
                      | grep -C1 "\<Name\>"                 \
                      | grep "\(Source\)\|\(Mountpoint\)"   \
                      | cut -d'"' -f4                       \
                    ) -type s -print | cut -d' ' -f1        \
                )"

                [[ -z "${firstSocket}" ]] && error "${optarg}: bad socket path"

                # Extract the volume ID and path to socket from firstSocket. We
                # mount the entire volume and not just the socket file because
                # we would have to be root to do the latter. firstSocket is in
                # this form:
                #   /var/lib/docker/volumes/<volume-ID>/_data/path/to/socket
                # We do not know whether this is configurable - we rely on the
                # "_data" being present.
                [[ ! "${firstSocket}" =~ ^.+/([^/]+)/_data/(.+)$ ]] && \
                    error "${optarg}: cannot determine volume name and socket path"
                local volname="${BASH_REMATCH[1]}"
                local sockpath="${BASH_REMATCH[2]}"

                appendArrayVar "${sidecarPrefix}" dockerOpts                \
                    "--volume=${volname}:/tmp/spire-agent"                  \
                    "--env=SWARM_SPIFFE_WORKLOAD_API_SOCKET_PATH=/tmp/spire-agent/${sockpath}"
            fi

            appendArrayVar "${sidecarPrefix}" dockerOpts    \
                "--label=swarm-node-type=${componentName}"
            ;;

        *) unprocessedOpts+=("${origParam}"); nShift=1;;
    esac

    return 0
}


# Process the train of command line arguments.
processTrain()
{
    local category="${1}"
    local sidecar="${2}"
    local sidecarPrefix="$(CamelCase "${2}")"
    shift 2

    local genericProcessBatchOptFunc="process${category}BatchOpt"
    local genericOnBatchBeginFunc="on${category}BatchBegin"
    local genericOnBatchEndFunc="on${category}BatchEnd"

    local sidecarProcessBatchOptFunc="process${sidecarPrefix}${category}BatchOpt"
    local sidecarOnBatchBeginFunc="on${sidecarPrefix}${category}BatchBegin"
    local sidecarOnBatchEndFunc="on${sidecarPrefix}${category}BatchEnd"

    local processBatchOptFunc=$(                                \
        declare -F "${sidecarProcessBatchOptFunc}" > /dev/null  \
         && echo "${sidecarProcessBatchOptFunc}"                \
         || echo "${genericProcessBatchOptFunc}"                \
    )
    local onBatchBeginFunc=$(                                   \
        declare -F "${sidecarOnBatchBeginFunc}" > /dev/null     \
         && echo "${sidecarOnBatchBeginFunc}"                   \
         || echo "${genericOnBatchBeginFunc}"                   \
    )
    local onBatchEndFunc=$(                                     \
        declare -F "${sidecarOnBatchEndFunc}" > /dev/null       \
         && echo "${sidecarOnBatchEndFunc}"                     \
         || echo "${genericOnBatchEndFunc}"                     \
    )

    # After reading through https://stackoverflow.com/questions/85880, we could
    # not decide whether "type" is better than "declare". So we adopted a very
    # scientific approach - we tossed a coin.
    declare -F "${onBatchBeginFunc}" > /dev/null &&    \
        ${onBatchBeginFunc} "${sidecar}"

    declare -F "${processBatchOptFunc}" > /dev/null
    if [ ${?} -eq 0 ]
    then
        unprocessedOpts=()  # Global.

        while [ ${#} -gt 0 ]
        do
            if [[ "${1}" =~ (-[^=]+)(=(.*)) ]]
            then
                local opt="${BASH_REMATCH[1]}"
                local optarg="${BASH_REMATCH[3]}"
                nShift=1    # Global.
            else
                local opt="${1}"
                local optarg="${2}"
                nShift=2    # Global.
            fi

            if [ "${opt}" == "--" ]
            then
                shift
                # All remaining arguments are passed to the main container, not
                # sidecars.
                cmd+=("${@}")
                break
            fi

            ${processBatchOptFunc} "${sidecar}" "${1}" "${opt}" "${optarg}"

            shift ${nShift}
        done
    fi

    declare -F "${onBatchEndFunc}" > /dev/null &&   \
        ${onBatchEndFunc} "${sidecar}"

    return 0
}


dockerRun()
{
    local sidecar="${1}"
    [[ -n "${sidecar}" ]] && local sidecarPrefix="${sidecar}-"
    shift

    declare -n imgVar=$(makeVarName "${sidecarPrefix}" image)
    [[ -z "${imgVar}" ]] && {
        [[ -n "${sidecar}" ]] && msg="sidecar ${sidecar}" || msg="internal error"
        msg="${msg}: no image specified"
        error "${msg}"
    }

    declare -n dockerOptsVar=$(makeVarName "${sidecarPrefix}" dockerOpts)
    declare -n cmdVar=$(makeVarName "${sidecarPrefix}" cmd)
    declare -n pidMainVar=$(makeVarName "${sidecarPrefix}" pidMain)
    declare -n volumesFromMainVar=$(makeVarName "${sidecarPrefix}" volumesFromMain)

    # Interactive mode and terminal allocation are two separate things and
    # so, should be handled separately. Also, our earlier understanding of
    # detached and interactive modes was wrong - they are, again, separate
    # things and are not mutually exclusive - for an example where they are
    # used together, see https://github.com/moby/moby/issues/12974. In fact,
    # the correct way to start bash in detached mode is:
    #   docker run -dit --entrypoint=bash ubuntu
    # Or, using container commands:
    #   docker container create -it --entrypoint=bash ubuntu
    #   docker container start <container ID>
    # To issue commands and view output, use:
    #   docker attach <container ID>
    # The counterpart for "--detach" is "--attach". This parameter is used
    # to attach any of stdin, stdout AND stderr. "--interactive" opens the
    # stdin. "-a" without the "-i" attaches to stdin but, does not open it:
    #                | -ait  | -at   | -dit  | -dt   | -it
    #   -------------|-------|-------|-------|-------|-------
    #   AttachStdin  | true  | true  | false | false | true
    #   AttachStdout | true  | true  | false | false | true
    #   AttachStderr | true  | true  | false | false | true
    #   Tty          | true  | true  | true  | true  | true
    #   OpenStdin    | true  | false | true  | false | true
    #   StdinOnce    | true  | false | false | false | true
    # We do not pretend to understand what an attached-but-closed-stdin is.
    # Nor do we pretend to understand why OpenStdout and OpenStderr fields
    # are missing. But, an input typed on the terminal of such a container
    # is not delivered to the bash process inside it. The whole setup gives
    # the impression of hanging - but, in reality, commands are simply not
    # being delivered to the target process.
    # So much for the theory. In our practice, we always open the stdin and
    # allocate a terminal unless the user has specifically instructed us not
    # to do so (using -i=false -t=false):
    #   docker container create -it <image>
    #   docker container start <container ID>
    # And, after starting all containers, we attach to the first container
    # (starting with the main one) that does not have a "-d". Note that this
    # is a change from our older behaviour where we treated the -i and -d as
    # complementary flags and used -d to turn off -i. Why? Because we have
    # had trouble with stopping and detaching containers. The documentation
    # (https://docs.docker.com/engine/reference/commandline/attach) says:
    #       To stop a container, use CTRL-c. This key sequence sends SIGKILL
    #       to the container. If --sig-proxy is true (the default), CTRL-c
    #       sends a SIGINT to the container. If the container was run with
    #       -i and -t, you can detach from a container and leave it running
    #       using the CTRL-p CTRL-q key sequence.
    # We tested this claim and found it to be only partly correct. The claim
    # about detaching is correct - the escape sequence of ctrl-p ctrl-q does
    # not work until and unless both -i and -t flags are specified. The part
    # about ctrl-c stopping a container does not pass muster. The container
    # stops reliably only when, again, both -i and -t flags are provided. We
    # do not know where the problem really lies in the other cases - whether
    # docker even receives the signal in the first place (and we do not have
    # a case where this parent bash script intercepts without forwarding to
    # the child process), whether docker receives the signal but, does not
    # send it to the container, whether the container fails to receive it,
    # or whether the container's init process fails to process it and die.
    ! hasItem "dockerOpts" "${sidecarPrefix}" "--interactive" "q" &&    \
        dockerOptsVar+=("--interactive=true")

    # Decide whether we want to allocate a terminal for our container. We cannot
    # do so when we are, say, running in nohup mode, or, are at the consumer end
    # of a pipe, and so, do not have a terminal to associate with:
    #       Specifying -t is forbidden when the client is receiving its standard
    #       input from a pipe
    #   - https://docs.docker.com/engine/reference/run/#foreground
    ! hasItem "dockerOpts" "${sidecarPrefix}" "--tty" "q" && tty -s &&  \
        dockerOptsVar+=("--tty=true")

    [[ -n "${pidMainVar}" ]] && dockerOptsVar+=("--pid=${containerID}")
    [[ -n "${volumesFromMainVar}" ]] && \
        dockerOptsVar+=("--volumes-from=${containerID}")
    
    # The below code is to replicate the fix given for 1.1.0 release
    # This logic checks if user argument (--ml-user) is not passed to ml 
    # container explicitly, then it defaults or runs the ml container with 
    # current "host machine" user id and primary group id.
    ! hasItem "dockerOpts" "${sidecarPrefix}" "--user" "q" &&  \
    [[ ${sidecarPrefix} == "ml-" ]] && \
        dockerOptsVar+=("--user=$(id -u):$(id -g)")


    # This is the additional safety to check and error out when any unsupported 
    # arguments are used in the ML container.
    match="--ml"
    # Loop through the items and error out if any argument that starts with the match string.
    for i in "${!cmdVar[@]}"; do
    if [[ "${cmdVar[$i]}" == "$match"* ]]; then
        echo "Error: ${cmdVar[$i]} is an unsupported option."  
        exit 1
    fi
    done

    declare -n containerIDVar=$(makeVarName "${sidecarPrefix}" containerID)
    containerIDVar=$(${sudo} docker container create    \
        "${dockerOptsVar[@]}"                           \
        "${imgVar}"                                     \
        "${cmdVar[@]}"                                  \
        "${@}"                                          \
    )
    
    #echo "docker container create" "${dockerOptsVar[@]}" "${imgVar}" "${cmdVar[@]}" "${@}"

    ret=${?}

    if [[ ${ret} -eq 0 ]]
    then
        # mktemp will take care of name collusion in multi process env.
        CONTAINER_INFO_FILE=`mktemp`
        echo ${containerIDVar} > ${CONTAINER_INFO_FILE}
        # .Config.Image returns image name with tag.
        ${sudo} docker inspect -f '{{.Config.Image}}' ${containerIDVar}  >> ${CONTAINER_INFO_FILE}
        # .Image returns image id in format of sha256:<id>.
        ${sudo} docker inspect -f '{{.Image}}' ${containerIDVar}  >> ${CONTAINER_INFO_FILE}
        chmod +r ${CONTAINER_INFO_FILE}  #so that non root user can also read it inside container e.g. in podman env
        # docker cp can copy to stopped container too
        ${sudo} docker cp ${CONTAINER_INFO_FILE} ${containerIDVar}:/tmp/container_info_file
        # Following are the sample contents of container_info_file file
        # 0c1bddc56780b51f752a1ae75fe25f4b10bd4ffb0b34a4cf27eaa29c01d24cc2
        # hub.docker.hpecorp.net/swarm-learning/swop:1.1.0
        # sha256:760271a15e7f88f33ea20051aa42b2b2f8c04da42f6f89deeaa45393de6967a5

        rm -f ${CONTAINER_INFO_FILE}
    fi

    [[ ${ret} -eq 0 ]] && ${sudo} docker container start ${containerIDVar}
    ret=${?}

    return ${ret}
}


# Params:
#   1. User-specified sidecar name. This will be camel-cased and prefixed to the
#      variable names.
createContainerVars()
{
    [[ -n "${1}" ]] && local sidecarPrefix="${1}-"

    # Parameters to pass to "docker container create".
    # As a convention, we use the long form of docker options when we add items
    # to this array - so, --env instead of -e and --volume instead of -v. This
    # makes searching the array (see hasItem) a little easier.
    assignArrayVar "${sidecarPrefix}" "dockerOpts"

    # Arguments to pass to the container entry point.
    assignArrayVar "${sidecarPrefix}" "cmd"

    return 0
}


main()
{
    # We need to preserve whitespaces. So, all of these are arrays, not simple
    # variables. See https://mywiki.wooledge.org/BashFAQ/050. The empty brackets
    # are required to create empty arrays correctly. Without them, we will need
    # empty-array checks all over the place or, we will end up with arrays that
    # have an extra element - an empty string as the very first item - and, we
    # will end up with checks for that all over the place.

    # Command line parameters that we do not recognize. The caller should check
    # the value of this variable after we return and, process it suitably.
    unprocessedOpts=("${@}")

    declare -F onTrainBegin > /dev/null && onTrainBegin

    processTrain Sidecar "" "${unprocessedOpts[@]}"

    for sidecar in "${sidecars[@]}"
    do
        createContainerVars "${sidecar}"

        for funcName in "${funcCallOrder[@]}"
        do
            processTrain "${funcName}" "${sidecar}" "${unprocessedOpts[@]}"
        done
    done

    declare -F onTrainEnd > /dev/null && onTrainEnd

    for sidecar in "${sidecars[@]}"
    do
        local sidecarDockerRunFunc="$(camelCase "custom-${sidecar}-dockerRun")"
        local customDockerRunFunc="customDockerRun"
        local dockerRunFunc="dockerRun"

        local runFunc="${sidecarDockerRunFunc}"
        declare -F "${runFunc}" > /dev/null || runFunc="${customDockerRunFunc}"
        declare -F "${runFunc}" > /dev/null || runFunc="${dockerRunFunc}"

        # Note: unprocessedOpts is passed in to every container that we launch.
        # If this does not make sense, the caller should clear the array before
        # we get here.
        ${runFunc} "${sidecar}" "${unprocessedOpts[@]}"
        [[ ${?} -ne 0 ]] && exit 1
    done

    for sidecar in "${sidecars[@]}"
    do
        [[ -n "${sidecar}" ]] && local sidecarPrefix="${sidecar}-"
        
        # In earlier approach, we used to run things in interactive 
        # mode to view the logs. This has been changed to run the 
        # container in detached mode and to view logs, we are now
        # attaching using "docker attach" command for ease of use.
        declare -n detachVar=$(makeVarName "${sidecarPrefix}" detach)
        declare -n containerIDVar=$(makeVarName "${sidecarPrefix}" containerID)

        if [[ -z "${detachVar}" && -n "${containerIDVar}" ]]
        then
            ${sudo} docker logs ${containerIDVar}
            exec ${sudo} docker attach ${containerIDVar}

            # Should never come here - the previous statement is an exec.
            break
        fi
    done

    return 0
}
